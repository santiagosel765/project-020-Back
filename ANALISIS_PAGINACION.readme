# Informe de paginación y estabilidad de resultados

## 1. Normalización de parámetros comunes
- La mayoría de los endpoints usan `normalizePagination` para convertir `page`, `limit` y `sort` a números válidos y calcular `skip = (page - 1) * limit` y `take = limit` (paginación 1-based). Si `page` o `limit` no son enteros positivos, lanza `BadRequestException`; `limit` debe estar entre 1 y 100. `sort` se normaliza a `'asc'` o `'desc'`.【F:src/shared/utils/pagination.ts†L19-L59】
- El envoltorio actual devuelve `{ items, page, limit, sort, total, pages, hasPrev, hasNext }` con `pages = Math.ceil(total / limit)` (cuando `total = 0` responde `pages = 0`).【F:src/shared/utils/pagination.ts†L62-L79】

## 2. Origen y validación de `page`, `limit`, `sort`
- **Documentos**: El controlador recibe `ListQueryDto`, que exige `page` y `limit` enteros ≥ 1, `sort` en `['asc','desc']` y permite `search`/`estado`.【F:src/documents/dto/list-query.dto.ts†L3-L22】
- **Usuarios / Roles / Páginas**: Usan `PaginationDto`, que aplica `@Type(() => Number)` para convertir `page`/`limit`, valida que sean positivos y que `sort` sea `'asc' | 'desc'`.【F:src/common/dto/pagination.dto.ts†L4-L35】

## 3. GET `/api/documents/cuadro-firmas/documentos/supervision`
- Lógica en `DocumentsService.listSupervision`.
- Se normaliza la paginación con `skip = (page - 1) * limit`, `take = limit`. Usa filtros dinámicos (`search`, `estado`).【F:src/documents/documents.service.ts†L1141-L1153】
- Orden: `[{ add_date: sort }, { id: sort }]` para mantener orden estable por fecha y luego por PK.【F:src/documents/documents.service.ts†L1135-L1139】
- Consulta Prisma ejecuta `count` y `findMany` en la misma transacción con los mismos filtros, aplicando `orderBy`, `skip`, `take` e `include` de relaciones (solo añade datos relacionados, no multiplica filas).【F:src/documents/documents.service.ts†L1147-L1161】
- SQL aproximado:
  ```sql
  SELECT ...
  FROM "cuadro_firma" cf
  LEFT JOIN ... -- includes
  WHERE ...
  ORDER BY cf."add_date" DESC, cf."id" DESC
  OFFSET (page-1)*limit
  LIMIT limit;
  ```
  y un `SELECT COUNT(*) FROM "cuadro_firma" WHERE ...;`

## 4. GET `/api/documents/cuadro-firmas/by-user/:id`
- Misma normalización (`skip`, `take`) y orden estable (fecha + id).【F:src/documents/documents.service.ts†L1176-L1212】
- Filtro adicional `cuadro_firma_user some { user_id: userId }`. No hay `groupBy`; Prisma genera subconsultas en el `WHERE`, por lo que no duplica filas.
- SQL aproximado:
  ```sql
  SELECT ...
  FROM "cuadro_firma" cf
  WHERE ... AND EXISTS (
    SELECT 1 FROM "cuadro_firma_user" cfu
    WHERE cfu."cuadro_firma_id" = cf."id" AND cfu."user_id" = :userId
  )
  ORDER BY cf."add_date" DESC, cf."id" DESC
  OFFSET ... LIMIT ...;
  ```

## 5. GET `/api/users`
- `UsersService.findAll` usa `normalizePagination` (mismo `skip`/`take`).【F:src/users/users.service.ts†L135-L159】
- Orden: `[{ add_date: sort }, { id: sort }]` con cuenta + `findMany` dentro de `$transaction`. Incluye relaciones por `select`, sin `join` repetitivo.
- SQL aproximado: `SELECT ... FROM "user" WHERE activo=true ORDER BY add_date DESC, id DESC OFFSET ... LIMIT ...;`

## 6. GET `/api/roles`
- Misma estrategia: normalización compartida, orden estable (fecha + id), `count` + `findMany` en transacción.【F:src/roles/roles.service.ts†L21-L55】
- SQL aproximado: `SELECT ... FROM "rol" WHERE activo=true ORDER BY add_date DESC, id DESC OFFSET ... LIMIT ...;`

## 7. GET `/api/paginas`
- Igualmente `normalizePagination` + orden estable por fecha y luego id, con transacción `count/findMany`.【F:src/paginas/paginas.service.ts†L16-L41】
- SQL aproximado: `SELECT ... FROM "pagina" WHERE activo=true ORDER BY add_date DESC, id DESC OFFSET ... LIMIT ...;`

## 8. ¿Por qué `page=2` puede repetir resultados?
- Aunque todos los servicios amarran el orden por `add_date` e `id`, la paginación es basada en desplazamiento (`skip`/`take`). Si se inserta o actualiza un registro entre la petición a `page=1` y la de `page=2`, el conjunto ordenado cambia y el `OFFSET` apunta a filas distintas. Resultado: elementos del final de la primera página pueden aparecer de nuevo en la segunda (o algunos saltarse). Es un efecto inherente a la paginación con `OFFSET` sobre datos en movimiento.
- No hay problemas de joins que dupliquen filas ni fallos en el cálculo de `skip`. Tampoco se encontró uso de cache.
- Casos que agravan el síntoma:
  - Registros con el mismo `add_date`; aunque se desempatan con `id`, una actualización de fecha o la inserción de un nuevo registro al inicio causa corrimientos.
  - Cuando `total` es bajo, `Math.ceil(total / limit)` puede devolver 0, de modo que `hasNext`/`hasPrev` quedan inconsistentes, pero esto no explica la duplicidad.

## 9. Parches recomendados
A continuación se proponen diffs para reforzar la estabilidad y el contrato de paginación:

```diff
--- a/src/shared/utils/pagination.ts
+++ b/src/shared/utils/pagination.ts
@@
-export function normalizePagination(
-  pagination?: PaginationInput,
-): NormalizedPagination {
-  const rawPage = pagination?.page ?? 1;
-  const rawLimit = pagination?.limit ?? 10;
-  const rawSort = pagination?.sort ?? 'desc';
+const toInt = (value: unknown) => {
+  const num = Number(value);
+  return Number.isFinite(num) ? Math.trunc(num) : NaN;
+};
+
+const clamp = (value: number, min: number, max: number) =>
+  Math.min(Math.max(value, min), max);
+
+export function normalizePagination(
+  pagination?: PaginationInput,
+): NormalizedPagination {
+  const rawPage = pagination?.page ?? 1;
+  const rawLimit = pagination?.limit ?? 10;
+  const rawSort = pagination?.sort ?? 'desc';
 
-  const page = Number(rawPage);
-  if (!Number.isFinite(page) || !Number.isInteger(page)) {
-    throw new BadRequestException('El parámetro "page" debe ser un entero.');
-  }
-  if (page < 1) {
-    throw new BadRequestException('El parámetro "page" debe ser mayor o igual a 1.');
-  }
+  const parsedPage = toInt(rawPage);
+  if (Number.isNaN(parsedPage)) {
+    throw new BadRequestException('El parámetro "page" debe ser un entero.');
+  }
+  const page = clamp(parsedPage, 1, Number.MAX_SAFE_INTEGER);
 
-  const limit = Number(rawLimit);
-  if (!Number.isFinite(limit) || !Number.isInteger(limit)) {
-    throw new BadRequestException('El parámetro "limit" debe ser un entero.');
-  }
-  if (limit < 1 || limit > 100) {
-    throw new BadRequestException(
-      'El parámetro "limit" debe estar entre 1 y 100.',
-    );
-  }
+  const parsedLimit = toInt(rawLimit);
+  if (Number.isNaN(parsedLimit)) {
+    throw new BadRequestException('El parámetro "limit" debe ser un entero.');
+  }
+  const limit = clamp(parsedLimit, 1, 100);
 
@@
-  return {
-    page,
-    limit,
-    sort,
-    skip: (page - 1) * limit,
-    take: limit,
-  };
+  const take = limit;
+  const skip = (page - 1) * take;
+
+  return { page, limit: take, sort, skip, take };
 }
 
 export function buildPaginationResult< T >(
@@
-  const pages = Math.ceil(total / limit);
+  const pages = Math.max(1, Math.ceil(total / limit));
   return {
     items,
     page,
-    limit,
+    limit,
     sort,
     total,
     pages,
     hasPrev: page > 1,
     hasNext: page < pages,
   };
 }
```

Aplicar el mismo `orderBy` estable (fecha + id) en todos los servicios ya se cumple, pero se puede ajustar la sintaxis para dejarlo explícito:

```diff
-        orderBy: [
-          { add_date: sort },
-          { id: sort },
-        ],
+        orderBy: [
+          { add_date: sort },
+          { id: sort },
+        ],
```

(En `DocumentsService` ya existe `buildOrder`; en `UsersService`, `RolesService` y `PaginasService` podría extraerse una utilidad similar para garantizar consistencia.)

## 10. Prueba manual sugerida
1. Crear 15 registros en cualquiera de las tablas (`cuadro_firma`, `user`, `rol`, `pagina`).
2. Invocar `GET ...?limit=10&page=1&sort=desc` ⇒ deben retornarse 10 elementos más recientes.
3. Invocar `GET ...?limit=10&page=2&sort=desc` ⇒ deben mostrarse los 5 restantes en el mismo orden.
4. Insertar un nuevo registro y repetir las consultas para observar cómo el `OFFSET` desplaza el resultado y puede provocar la repetición que se mencionó.

## 11. Diagnóstico final por endpoint
- `/api/documents/cuadro-firmas/documentos/supervision`: Implementación correcta; el comportamiento observado se debe al desfase de `OFFSET` cuando entran nuevos documentos. Recomendado considerar paginación por cursor si se requiere consistencia estricta.
- `/api/documents/cuadro-firmas/by-user/:id`: Igual que el anterior, correcto pero vulnerable al mismo fenómeno por inserciones concurrentes.
- `/api/users`: Correcto, con orden estable. Misma recomendación si se quiere evitar duplicados por inserciones concurrentes.
- `/api/roles`: Correcto. Ajustar `buildPaginationResult` para que `pages` nunca sea 0.
- `/api/paginas`: Correcto. Idénticas observaciones.

Implementar los parches propuestos en `pagination.ts` mejoraría la robustez (clamp y `pages ≥ 1`), aunque el problema de repetición sólo se mitiga definitivamente migrando a paginación por cursor/"keyset" o usando snapshots de lectura.
